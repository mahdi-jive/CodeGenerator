using CodeGenerator.Abstractions;
using CodeGenerator.Assembly.Abstractions;
using CodeGenerator.Assembly.NetFx48.Extensions;
using CodeGenerator.Assembly.Template.NetTiers.Extensions;
using CodeGenerator.Assembly.Template.NetTiers.Model.DatabaseInfo.DatabaseModel;
using CodeGenerator.Assembly.Template.NetTiers.Model.DatabaseInfo.Table;
using CodeGenerator.Assembly.Template.NetTiers.Model.DatabaseInfo.Table.Column;
using CodeGenerator.Infrastructure;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace CodeGenerator.Assembly.Template.NetTiers.Entities
{
    public class ITableEntityTemp : ICodeTemplate<EntitiesFactory, DatabaseInfoModel>
    {
        #region Interface
        private SyntaxList<UsingDirectiveSyntax> GetUsing()
        {
            return List<UsingDirectiveSyntax>(
         new UsingDirectiveSyntax[]{
            UsingDirective(
                IdentifierName("System")),
            UsingDirective(
                QualifiedName(
                    IdentifierName("System"),
                    IdentifierName("ComponentModel")))});
        }
        private NamespaceDeclarationSyntax GetNamespace(string RootNamespace)
        {
            return NamespaceDeclaration(
            QualifiedName(
                IdentifierName(RootNamespace),
                IdentifierName("Entities")));
        }
        private InterfaceDeclarationSyntax GetInterface(string name)
        {
            return InterfaceDeclaration($"I{name.PascalCaseCustom()}");//TbasBuildingGroup
        }
        private SyntaxTriviaList GetDocumentInterface(string name)
        {
            var summaryXml = $"The data structure representation of the '{name}' table via interface.".ToSummaryXml();
            var remarkXml = "This struct is generated by a tool and should never be modified.".ToRemarksXml();
            var xmlNodes = summaryXml.ToList();
            xmlNodes.AddRange(remarkXml);
            return TriviaList(
                                Trivia(
                                    DocumentationCommentTrivia(
                                        SyntaxKind.SingleLineDocumentationCommentTrivia,
                                        List(xmlNodes))));
        }
        #endregion Interface
        #region Column
        private async Task<IEnumerable<PropertyDeclarationSyntax>> GetPropertyColumn(ITable table)
        {
            List<PropertyDeclarationSyntax> properties = new List<PropertyDeclarationSyntax>();

            foreach (var column in await table.Columns)
            {
                SyntaxTriviaList document = GetDocumentPropertyColumn(column, table.Name);
                if (column.IsPrimaryKey && !column.IsIdentity)
                {
                    var columnOriginalId = new
                           ColumnTable(
                           "OriginalId",
                           0,
                           "keep a copy of the original so it can be used for editable primary keys.",
                           table.Name,
                           table.ObjectId,
                           column.DataType.Sql,
                           column.MaxLength,
                           column.Precision,
                           column.Scale,
                           column.Collation,
                           true,
                           false,
                           column.IsComputed,
                           column.IsRowGuid,
                           column.IsSparse,
                           column.GeneratedAlwaysType,
                           false,
                           null);
                    var documentOriginalId = GetDocumentPropertyColumn(columnOriginalId, table.Name);
                    properties.Add(GetPropertyColumn(columnOriginalId, documentOriginalId));
                }
                properties.Add(GetPropertyColumn(column, document));
            }
            return properties;
        }
        private PropertyDeclarationSyntax GetPropertyColumn(IColumnTable column, SyntaxTriviaList? document = null)
        {
            var property = PropertyDeclaration(ParseTypeName(column.DataType.CSharpType), column.NamePascal)
                .AddAccessorListAccessors
                (
                    AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                    AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                    .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                );
            if (document != null)
            {
                property = property.WithLeadingTrivia(document);
            }

            return property;
        }
        private SyntaxTriviaList GetDocumentPropertyColumn(IColumnTable column, string tableName)
        {
            var summaryXml = $" {column.Name} : {column.Description ?? ""} ".ToSummaryXml();

            var xmlNodes = summaryXml.ToList();

            if (column.IsPrimaryKey)
            {
                var remarksXml = $"Member of the primary key of the underlying table \"{tableName}\"".ToRemarksXml();
                xmlNodes.AddRange(remarksXml);
            }

            var docComment = DocumentationCommentTrivia(
                SyntaxKind.SingleLineDocumentationCommentTrivia,
                List(xmlNodes)
            );

            return TriviaList(SyntaxFactory.Trivia(docComment));
        }
        #endregion Column

        private SyntaxTriviaList GetDocumentPropertyRelation(IRelationTable relation)
        {
            var description = "Holds a collection of entity objects"
                + $"\nwhich are related to this object through the relation {relation.Name}";

            var summaryXml = description.ToSummaryXml();

            var xmlNodes = summaryXml.ToList();

            var docComment = DocumentationCommentTrivia(
                SyntaxKind.SingleLineDocumentationCommentTrivia,
                List<XmlNodeSyntax>(summaryXml)
            );

            return TriviaList(SyntaxFactory.Trivia(docComment));
        }
        private PropertyDeclarationSyntax GetPropertyRelationCollection(IRelationTable relation)
        {
            var document = GetDocumentPropertyRelation(relation);
            var property = PropertyDeclaration(GenericName(
        Identifier("TList"))
                .WithTypeArgumentList(TypeArgumentList(
                    SingletonSeparatedList<TypeSyntax>(
                        IdentifierName($"{relation.TableName.PascalCaseCustom()}")))),
                        Identifier($"{relation.TableName.PascalCaseCustom()}Collection"))
                        .WithAccessorList(AccessorList(List<AccessorDeclarationSyntax>(
                            new AccessorDeclarationSyntax[]{
                                            AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
                                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken)),
                                            AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
                                            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken))
                            }))).WithLeadingTrivia(document);
            return property;
        }
        private async Task<IEnumerable<PropertyDeclarationSyntax>> GetPropertyRelationCollection(ITable table)
        {
            List<PropertyDeclarationSyntax> properties = new List<PropertyDeclarationSyntax>();

            foreach (var relation in await table.Relations)
            {
                properties.Add(GetPropertyRelationCollection(relation));
            }
            return properties;
        }

        private async Task<IEnumerable<ICodeFile>> GetCompilationUnit(DatabaseInfoModel model)
        {
            List<ICodeFile> codeFiles = new List<ICodeFile>();
            foreach (var table in await model.Tables)
            {
                var propertyColumns = await GetPropertyColumn(table);
                var propertyRelation = await GetPropertyRelationCollection(table);
                var tree = CompilationUnit()
                    .WithUsings(GetUsing()).WithMembers(SingletonList<MemberDeclarationSyntax>(
                        GetNamespace(model.RootNameSpace)
                        .WithMembers(SingletonList<MemberDeclarationSyntax>(
                GetInterface(table.Name)
                .WithModifiers(TokenList(
                    Token(
                    GetDocumentInterface(table.Name),
                    SyntaxKind.PublicKeyword,
                    TriviaList())))
                .AddMembers(propertyColumns.ToArray())
                .AddMembers(propertyRelation.ToArray())
                .WithCloseBraceToken(Token(TriviaList(Trivia(EndRegionDirectiveTrivia(true)
                .WithEndOfDirectiveToken(
                    Token(
                        TriviaList(PreprocessingMessage("Data Properties")),
                        SyntaxKind.EndOfDirectiveToken,
                        TriviaList())))),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())))))).NormalizeWhitespace();
                codeFiles.Add(new CodeFile($"I{table.Name.PascalCaseCustom()}.cs", $"I{table.Name.PascalCaseCustom()}", tree));
            }

            return codeFiles;
        }
        public async Task<IEnumerable<ICodeFile>> Generate(ITemplateRenderer renderer, IContextModel contextModel)
        {
            IEnumerable<ICodeFile> codeFiles = new List<ICodeFile>();
            var model = contextModel as DatabaseInfoModel;
            if (model != null)
            {
                codeFiles = await GetCompilationUnit(model);
            }

            return codeFiles;
        }
    }
}
